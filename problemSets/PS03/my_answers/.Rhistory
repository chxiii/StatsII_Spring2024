c("num_v1",
"num_v2",
"num_v3",
"num_v4",
"num_v5",
"num_v6",
"num_v7")
## Background items
c("c_alphan", # Country abbreviation
"AGE_c", # Age (coded as factor)
"SEX", # Sex of respondent
"DEGREE", # Highest completed degree (derived) - different levels to ISSP4
"MAINSTAT", # Main status (employment) - different levels to WRKST
"ISCO08", # Occupation ISCO 2008
"PARTY_LR", # Party voted for last election
"URBRURAL", # Place of living: urban - rural
"v61", # Social class (self-reported)
"v67", # Father's Occupation
"v68", # Mother's Occupation
"v69", # Own occupation
"v70", # Partner's Occupation
"WEIGHT") # Sampling weights
## Country list (c_alphan)
c("AU", # Australia
"GB-GBN", # Great Britain
"US", # United States
"NZ", # New Zealand
"JP", # Japan
"TW", # Taiwan
"DE", # Germany
"FR", # France
"IT", # Italy
"SE", # Sweden
"DK", # Denmark
"FI", # Finland
"NO", # Norway
"RU", # Russia
"VE", # Venezuela
"PH" # Philippines
)
# rename levels
dat$v48s <- dat$v48
levels(dat$v48s) <- c("A", "B", "C", "D", "E")
# rename v49 levels
dat$v49s <- dat$v49
levels(dat$v49s) <- c("A", "B", "C", "D", "E")
knitr::kable(addmargins(table(dat$v48s, dat$c_alphan)), caption = "Contingency Table: \"Country is\" by Country")
active.variables <- c("num_v1", # wealthy family
"num_v2", # well-educated parents
"num_v3", # own education
"num_v4", # hard work
"num_v5", # knowing right people
"num_v6", # political connections
"num_v7") # bribes
mod.pca <- pca(dat[,active.variables], # subset on our chosen variables
nfactors = 7, # we want all the components
covar = FALSE, # setting covar to false means pca on the correlation matrix
rotate = "none") # we don't want our components rotating
biplot(mod.pca, choose = c(2,1), smoother = T) # we present a biplot of the first two components
fa.parallel(dat[,active.variables],
fa = "pc", # set this to "pc" for PCA
sim = FALSE
)
## The output from the pca() function contains useful information which can
## be readily extracted.
round(mod.pca$Vaccounted[1:3,],3) # eigenvalues and variance explained - used for retaining components
xtab <- xtabs(~v48s + c_alphan, data = dat)
(xtab.summary <- summary(xtab))
ca <- CA(xtab)
summary(ca, nbelements = Inf) # use the nbelements argument to obtain data for all categories
## Inertia of contingency table (chisq/n.cases, OR sum of eigenvalues)
sum(ca$eig[,1])
xtab.summary$statistic/xtab.summary$n.cases
knitr::kable(round(ca$eig,2), caption = "CA axes")
ca$row
ca$col
knitr::kable(round(ca$col$contrib,2), caption = "Column contributions")
# select active variables
active.variables <- c(
"v48s", # Type of country is
"v49s", # Type of country prefer
"v3", # own education
"v6", # political connections
"v4", # hard work
"v7" # bribes
)
dat.mca <- dat %>%
select(active.variables) %>%
filter(complete.cases(.))
mca <- MCA(dat.mca,
graph = FALSE) # default plotting in FactoMineR can be uninformative
summary(mca)
K <- length(unlist(lapply(dat.mca, unique)))
Q <- length(active.variables)
phisq <- K/Q - 1
sum(mca$eig[,1]) # equal to sum of eigenvalues
mca$eig
# First, calculate the critical threshold (1/Q) for retaining eigenvalues and
# discard those below the threshold
eig.retain <- mca$eig[,1][mca$eig[,1] > 1/Q]
# Next, calculate the modified eigenvalue
mod.eig <- ((Q/(Q-1))*(eig.retain-1/Q))^2
# Next, calculate the modified rate (percentage explained variance) - tau
tau <- mod.eig/sum(mod.eig)
round(tau, 2)
mod.eig.r <- (eig.retain - 1/Q)^2
tau.r <- mod.eig.r/sum(mod.eig.r)
round(tau.r,2)
round(matrix(c(mod.eig, mod.eig.r), nrow = 2, byrow = T),4)
knitr::kable(matrix(round(c(mca$eig[1:11,1], mod.eig, tau*100, cumsum(tau*100)),3), nrow = 11, byrow = F,
dimnames = list(names(tau.r), c("eigenvalue", "mod. eig.", "modified rate", "cumulative rate"))),
caption = "Variance explained")
# First, we calculate the critical value for explanatory relevance
c.val <- 1/K *100
# Next, we create a series of tables for each axis which returns only
# the variables above that critical value. Here, we use the apply() and
# lapply() functions to vectorise the process.
ax.cont.tab <- lapply(apply(mca$var$contrib, 2, function(n) n[n >= c.val]),round,2)
# Finally, we sort the variables in decreasing order
lapply(ax.cont.tab, sort, decreasing = T)
# First, we create a logical matrix to subset on the critical value. We also
# convert this into a data frame
ax.cont <- as.data.frame(apply(mca$var$contrib, 2, function(n) n >= c.val))
# Next, we extract the category coordinates and convert those to a data frame
coord <- as.data.frame(mca$var$coord)
# Finally, we subset the coordinates on the basis of their contribution, and
# sort them in ascending order
# axis 1 coordinates
ax.1 <- round(coord[which(ax.cont[,1]),1, drop = F],2)
ax.1 <- arrange(ax.1,ax.1)
#axis 2 coordinates
ax.2 <- round(coord[which(ax.cont[,2]),2, drop = F],2)
ax.2 <- arrange(ax.2,ax.2)
knitr::kables(list(knitr::kable(ax.1), knitr::kable(ax.2)), caption = "Coordinates of top categories")
# select the top 10 contributing categories
p1 <- plot(mca, selectMod = c("contrib10"), invisible = "ind")
p1$labels$x <- paste0("Dim 1 (", round(tau.r[1]*100,2),"%)")
p1$labels$y <- paste0("Dim 2 (", round(tau.r[2]*100,2),"%)")
p1
knitr::opts_chunk$set(echo = TRUE)
# add necessary libraries in this chunk
```{r load data}
dat <- readRDS("ISSP5")
summary(dat)
View(dat)
# summary(dat) # check the data. because data list is too long, so I hide it.
dat <- na.omit(dat_raw)
dat_raw <- readRDS("ISSP5")
# summary(dat) # check the data. because data list is too long, so I hide it.
dat <- na.omit(dat_raw)
summary (dat)
# load data
gdp_data <- read.csv("https://raw.githubusercontent.com/ASDS-TCD/StatsII_Spring2024/main/datasets/gdpChange.csv", stringsAsFactors = F)
# load data
gdp_data <- read.csv("https://raw.githubusercontent.com/ASDS-TCD/StatsII_Spring2024/main/datasets/gdpChange.csv", stringsAsFactors = F)
View(gdp_data)
# first step, we need to recode the GDPWdiff variable with factor command:
# if < 0 - "negative"
# if = 0 - "no change"
# if > 0 - "positive"
gdp_data$GDPWdiff <- as.factor(gdp_data$GDPWdiff)
GDPWdiff
gdp_data$GDPWdiff
# first step, we need to recode the GDPWdiff variable with factor command:
# if < 0 - "negative"
# if = 0 - "no change"
# if > 0 - "positive"
gdp_data$GDPWdiff <- ifelse(gdp_data$GDPWdiff > 0, "positive",
ifelse(gdp_data$GDPWdiff == 0, "no change", "negative"))
# load data
gdp_data <- read.csv("https://raw.githubusercontent.com/ASDS-TCD/StatsII_Spring2024/main/datasets/gdpChange.csv", stringsAsFactors = F)
# first step, we need to recode the GDPWdiff variable with factor command:
# if < 0 - "negative"
# if = 0 - "no change"
# if > 0 - "positive"
gdp_data$GDPWdiff <- ifelse(gdp_data$GDPWdiff > 0, "positive",
ifelse(gdp_data$GDPWdiff == 0, "no change", "negative"))
gdp_data$GDPWdiff
# first step, we need to recode the GDPWdiff variable with ifelse command:
# if < 0 - "negative"
# if = 0 - "no change"
# if > 0 - "positive"
gdp_data$GDPWdiff <- ifelse(gdp_data$GDPWdiff > 0, "positive",
ifelse(gdp_data$GDPWdiff == 0, "no change", "negative"))
# transfer GDPWdiff into factor variable,
# this step is to make sure we can put GDPWdiff into response variable
gdp_data$GDPWdiff <- as.factor(gdp_data$GDPWdiff)
gdp_data$GDPWdiff # check if we sucessfully
# first step, we need to recode the GDPWdiff variable with ifelse command:
# if < 0 - "negative"
# if = 0 - "no change"
# if > 0 - "positive"
gdp_data$GDPWdiff <- ifelse(gdp_data$GDPWdiff > 0, "positive",
ifelse(gdp_data$GDPWdiff == 0, "no change", "negative"))
# transfer GDPWdiff into factor variable,
# this step is to make sure we can put GDPWdiff into response variable
gdp_data$GDPWdiff <- as.factor(gdp_data$GDPWdiff)
gdp_data$GDPWdiff # check if we sucessfully
# load data
gdp_data <- read.csv("https://raw.githubusercontent.com/ASDS-TCD/StatsII_Spring2024/main/datasets/gdpChange.csv", stringsAsFactors = F)
# first step, we need to recode the GDPWdiff variable with ifelse command:
# if < 0 - "negative"
# if = 0 - "no change"
# if > 0 - "positive"
gdp_data$GDPWdiff <- ifelse(gdp_data$GDPWdiff > 0, "positive",
ifelse(gdp_data$GDPWdiff == 0, "no change", "negative"))
# transfer GDPWdiff into factor variable,
# this step is to make sure we can put GDPWdiff into response variable
gdp_data$GDPWdiff <- as.factor(gdp_data$GDPWdiff)
gdp_data$GDPWdiff # check if we sucessfully
# second step, let's fit the model, hu-rrray!
# we have these 2 predictors:
# - REG: 1 for Democracy, 0 for Non-Democracy
# - OIL: 1 for the average ratio of fuel exports in 1984-86 exceeded 50%;
#        0 for otherwise
p1_model <- multinom(GDPWdiff ~ REG + OIL,
data = gdp_data)
#####################
# load libraries
# set wd
# clear global .envir
#####################
# remove objects
rm(list=ls())
# detach all libraries
detachAllPackages <- function() {
basic.packages <- c("package:stats", "package:graphics", "package:grDevices", "package:utils", "package:datasets", "package:methods", "package:base")
package.list <- search()[ifelse(unlist(gregexpr("package:", search()))==1, TRUE, FALSE)]
package.list <- setdiff(package.list, basic.packages)
if (length(package.list)>0)  for (package in package.list) detach(package,  character.only=TRUE)
}
detachAllPackages()
# load libraries
pkgTest <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[,  "Package"])]
if (length(new.pkg))
install.packages(new.pkg,  dependencies = TRUE)
sapply(pkg,  require,  character.only = TRUE)
}
# here is where you load any necessary packages
# ex: stringr
# lapply(c("stringr"),  pkgTest)
lapply(c("nnet", "MASS"),  pkgTest)
# set wd for current folder
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# load data
gdp_data <- read.csv("https://raw.githubusercontent.com/ASDS-TCD/StatsII_Spring2024/main/datasets/gdpChange.csv", stringsAsFactors = F)
# first step, we need to recode the GDPWdiff variable with ifelse command:
# if < 0 - "negative"
# if = 0 - "no change"
# if > 0 - "positive"
gdp_data$GDPWdiff <- ifelse(gdp_data$GDPWdiff > 0, "positive",
ifelse(gdp_data$GDPWdiff == 0, "no change", "negative"))
# transfer GDPWdiff into factor variable,
# this step is to make sure we can put GDPWdiff into response variable
gdp_data$GDPWdiff <- as.factor(gdp_data$GDPWdiff)
gdp_data$GDPWdiff # check if we sucessfully
# second step, let's fit the model, hu-rrray!
# we have these 2 predictors:
# - REG: 1 for Democracy, 0 for Non-Democracy
# - OIL: 1 for the average ratio of fuel exports in 1984-86 exceeded 50%;
#        0 for otherwise
p1_model <- multinom(GDPWdiff ~ REG + OIL,
data = gdp_data)
summary(p1_model)
# second step, let's fit the model, hu-rrray!
# we have these 2 predictors:
# - REG: 1 for Democracy, 0 for Non-Democracy
# - OIL: 1 for the average ratio of fuel exports in 1984-86 exceeded 50%;
#        0 for otherwise
p1_model <- multinom(GDPWdiff ~ REG + OIL,
data = gdp_data,
# then we set "no change" as our reference level
contrasts = list(GDPWdiff = contr.treatment(reference = "no change")))
summary(p1_model)
# load data
gdp_data <- read.csv("https://raw.githubusercontent.com/ASDS-TCD/StatsII_Spring2024/main/datasets/gdpChange.csv", stringsAsFactors = F)
# first step, we need to recode the GDPWdiff variable with ifelse command:
# if < 0 - "negative"
# if = 0 - "no change"
# if > 0 - "positive"
gdp_data$GDPWdiff <- ifelse(gdp_data$GDPWdiff > 0, "positive",
ifelse(gdp_data$GDPWdiff == 0, "no change", "negative"))
# transfer GDPWdiff into factor variable,
# this step is to make sure we can put GDPWdiff into response variable
gdp_data$GDPWdiff <- as.factor(gdp_data$GDPWdiff)
gdp_data$GDPWdiff # check if we sucessfully
# second step, let's fit the model, hu-rrray!
# we have these 2 predictors:
# - REG: 1 for Democracy, 0 for Non-Democracy
# - OIL: 1 for the average ratio of fuel exports in 1984-86 exceeded 50%;
#        0 for otherwise
# and before we fit the model, we should remember to regard "no change"
# as our reference level
gdp_data$GDPWdiff <- relevel(gdp_data$GDPWdiff, ref = "no change")
# fit the model
p1_model <- multinom(GDPWdiff ~ REG + OIL,
data = gdp_data)
summary(p1_model)
coef(p1_model)
exp(coef(p1a_model)[,c(1:5)])
# fit the model
p1a_model <- multinom(GDPWdiff ~ REG + OIL,
data = gdp_data)
summary(p1a_model)
exp(coef(p1a_model)[,c(1:5)])
exp(coef(p1a_model)[,c(1:2)])
exp(coef(p1a_model)[,c(1:3)])
# forth step, visualisation the model prediction results
# (1) we need to extract the predicted values
predicted_values <- cbind(gdp_data, predict(p1a_model,
newdata = gdp_data,
type = "probs", se = TRUE))
predicted_values
View(gdp_data)
# forth step, visualisation the model prediction results
# (1) we need to extract the predicted values
predicted_values <- cbind(gdp_data, predict(p1a_model,
data = gdp_data,
type = "probs", se = TRUE))
predicted_values
by(predicted_values[, 14:16], predicted_values$OIL, colMeans)
# forth step, visualisation the model prediction results
# (1) we need to extract the predicted values
predicted_values <- cbind(gdp_data, predict(p1a_model,
data = gdp_data,
type = "probs", se = TRUE))
by(predicted_values[, 14:16], predicted_values$OIL, colMeans)
ggplot(predicted_values, aes(x = REG)) +
geom_line(aes(y = positive), color = "blue", linetype = "solid") +
geom_line(aes(y = negative), color = "red", linetype = "dashed") +
labs(x = "REG", y = "Predicted Probability", title = "Predicted Probability Curve") +
theme_minimal()
lapply(c("nnet", "MASS", "ggplot"),  pkgTest)
lapply(c("nnet", "MASS", "ggplot2"),  pkgTest)
ggplot(predicted_values, aes(x = REG)) +
geom_line(aes(y = positive), color = "blue", linetype = "solid") +
geom_line(aes(y = negative), color = "red", linetype = "dashed") +
labs(x = "REG", y = "Predicted Probability", title = "Predicted Probability Curve") +
theme_minimal()
ggplot(predicted_values, aes(x = REG)) +
geom_line(aes(y = positive), color = "blue", linetype = "solid") +
geom_line(aes(y = no change, color = "black", linetype = "solid")) +
ggplot(predicted_values, aes(x = REG)) +
geom_line(aes(y = positive), color = "blue", linetype = "solid") +
geom_line(aes(y = "no change", color = "black", linetype = "solid")) +
geom_line(aes(y = negative), color = "red", linetype = "dashed") +
labs(x = "REG", y = "Predicted Probability", title = "Predicted Probability Curve") +
theme_minimal()
ggplot(predicted_values, aes(x = REG)) +
geom_line(aes(y = positive), color = "blue", linetype = "solid") +
geom_line(aes(y = negative), color = "red", linetype = "dashed") +
labs(x = "REG", y = "Predicted Probability", title = "Predicted Probability Curve") +
theme_minimal()
ggplot(predicted_values, aes(x = REG)) +
geom_line(aes(y = positive), color = "blue", linetype = "solid") +
geom_line(aes(y = negative), color = "red", linetype = "dashed") +
labs(x = "REG", y = "Predicted Probability", title = "Predicted Probability Curve") +
theme_minimal()
ggplot(predicted_values, aes(x = as.factor(REG))) +
geom_line(aes(y = positive), color = "blue", linetype = "solid") +
geom_line(aes(y = negative), color = "red", linetype = "dashed") +
labs(x = "REG", y = "Predicted Probability", title = "Predicted Probability Curve") +
theme_minimal()
# load data
gdp_data <- read.csv("https://raw.githubusercontent.com/ASDS-TCD/StatsII_Spring2024/main/datasets/gdpChange.csv", stringsAsFactors = F)
# first step, we need to recode the GDPWdiff variable with ifelse command:
# if < 0 - "negative"
# if = 0 - "no change"
# if > 0 - "positive"
gdp_data$GDPWdiff <- ifelse(gdp_data$GDPWdiff > 0, "positive",
ifelse(gdp_data$GDPWdiff == 0, "no change", "negative"))
# transfer GDPWdiff into factor variable,
# this step is to make sure we can put GDPWdiff into response variable
gdp_data$GDPWdiff <- as.factor(gdp_data$GDPWdiff)
gdp_data$GDPWdiff # check if we successful
# second step, let's fit the model, hu-rrray!
# we have these 2 predictors:
# - REG: 1 for Democracy, 0 for Non-Democracy
# - OIL: 1 for the average ratio of fuel exports in 1984-86 exceeded 50%;
#        0 for otherwise
# and before we fit the model, we should remember to regard "no change"
# as our reference level
gdp_data$GDPWdiff <- relevel(gdp_data$GDPWdiff, ref = "no change")
# fit the model
p1a_model <- multinom(GDPWdiff ~ REG + OIL,
data = gdp_data)
summary(p1a_model)
# third step, exponentiation the coefficient to interpret
exp(coef(p1a_model)[,c(1:3)])
##### Problem 1b. the ordered regression model
p1b_model <- polr(GDPWdiff ~ REG + OIL,
data = gdp_data)
summary(p1b_model)
##### Problem 1b. the ordered regression model
gdp_data$GDPWdiff <- relevel(gdp_data$GDPWdiff)
##### Problem 1b. the ordered regression model
gdp_data$GDPWdiff <- relevel(gdp_data$GDPWdiff, ref = "negative")
p1b_model <- polr(GDPWdiff ~ REG + OIL,
data = gdp_data)
summary(p1b_model)
##### Problem 1b. the ordered regression model
gdp_data$GDPWdiff <- factor(gdp_data$GDPWdiff)
p1b_model <- polr(GDPWdiff ~ REG + OIL,
data = gdp_data)
summary(p1b_model)
#####################
# load libraries
# set wd
# clear global .envir
#####################
# remove objects
rm(list=ls())
# detach all libraries
detachAllPackages <- function() {
basic.packages <- c("package:stats", "package:graphics", "package:grDevices", "package:utils", "package:datasets", "package:methods", "package:base")
package.list <- search()[ifelse(unlist(gregexpr("package:", search()))==1, TRUE, FALSE)]
package.list <- setdiff(package.list, basic.packages)
if (length(package.list)>0)  for (package in package.list) detach(package,  character.only=TRUE)
}
detachAllPackages()
# load libraries
pkgTest <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[,  "Package"])]
if (length(new.pkg))
install.packages(new.pkg,  dependencies = TRUE)
sapply(pkg,  require,  character.only = TRUE)
}
# here is where you load any necessary packages
# ex: stringr
# lapply(c("stringr"),  pkgTest)
lapply(c("nnet", "MASS", "ggplot2"),  pkgTest)
# set wd for current folder
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#####################
# Problem 1
#####################
# load data
gdp_data <- read.csv("https://raw.githubusercontent.com/ASDS-TCD/StatsII_Spring2024/main/datasets/gdpChange.csv", stringsAsFactors = F)
##### Problem 1a. the un-ordered regression model
# first step, we need to recode the GDPWdiff variable with ifelse command:
# if < 0 - "negative"
# if = 0 - "no change"
# if > 0 - "positive"
gdp_data$GDPWdiff <- ifelse(gdp_data$GDPWdiff > 0, "positive",
ifelse(gdp_data$GDPWdiff == 0,
"no change", "negative"))
# transfer GDPWdiff into factor variable,
# this step is to make sure we can put GDPWdiff into response variable
gdp_data$GDPWdiff <- as.factor(gdp_data$GDPWdiff)
gdp_data$GDPWdiff # check if we successful
# the results show:
# Levels: negative no change positive. so we succeed.
# second step, let's fit the model, hu-rrray!
# we have these 2 predictors:
# - REG: 1 for Democracy, 0 for Non-Democracy
# - OIL: 1 for the average ratio of fuel exports in 1984-86 exceeded 50%;
#        0 for otherwise
# and before we fit the model, we should remember to regard "no change"
# as our reference level
gdp_data$GDPWdiff <- relevel(gdp_data$GDPWdiff, ref = "no change")
# fit the model
p1a_model <- multinom(GDPWdiff ~ REG + OIL,
data = gdp_data)
summary(p1a_model)
# third step, exponentiation the coefficient to interpret
exp(coef(p1a_model)[,c(1:3)])
##### Problem 1b. the ordered regression model
gdp_data$GDPWdiff <- factor(gdp_data$GDPWdiff)
p1b_model <- polr(GDPWdiff ~ REG + OIL,
data = gdp_data)
summary(p1b_model)
##### Problem 1b. the ordered regression model
gdp_data$GDPWdiff <- as.factor(gdp_data$GDPWdiff)
p1b_model <- polr(GDPWdiff ~ REG + OIL,
data = gdp_data)
summary(p1b_model)
##### Problem 1b. the ordered regression model
gdp_data$GDPWdiff <- factor(gdp_data$GDPWdiff,
ordered = TRUE,
levels = ["negative", "no change", "positive"])
##### Problem 1b. the ordered regression model
gdp_data$GDPWdiff <- factor(gdp_data$GDPWdiff,
ordered = TRUE,
levels = c("negative", "no change", "positive"))
p1b_model <- polr(GDPWdiff ~ REG + OIL,
data = gdp_data)
summary(p1b_model)
# third step, exponentiation the coefficient to interpret
exp(coef(p1b_model)[,c(1:3)])
summary(p1b_model)
View(p1b_model)
View(p1a_model)
# third step, exponentiation the coefficient to interpret
exp(coef(p1a_model)[,c(1:3)])
View(p1a_model)
coef(p1a_model)
coef(p1b_model)
# third step, exponentiation the coefficient to interpret
exp(coef(p1b_model)[,c(1:2)])
# third step, exponentiation the coefficient to interpret
exp(coef(p1b_model)[c(1:2)])
summary(p1b_model)
summary(p1a_model)
stargazer(p1a_model)
lapply(c("nnet", "MASS", "ggplot2", "stargazer"),  pkgTest)
stargazer(p1a_model)
summary(p1b_model)
stargazer()
summary(p1b_model)
stargazer()
stargazer(p1b_model)
